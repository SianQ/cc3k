#include "Halfling.h"
#include <cstdlib>

// static inline std::pair<int,int> dirToDelta(Direction d) {
//     switch (d) {
//         case Direction::North: return {-1, 0};
//         case Direction::South: return { 1, 0};
//         case Direction::East:  return { 0, 1};
//         case Direction::West:  return { 0,-1};
//         default:               return { 0, 0}; 
//     }
// }


Halfling::Halfling()
  : Enemy(100,15,20,"L",true,false) {}

// void Halfling::act(Map& map, Player& pc, Level& level) {
//     if (this->isDead()) return;

//     // check if the player is adjacent, if so, attack if isAttackSuccess is true (a random chance generated by level)
//     if (std::abs(pc.getPosition().first - row) + std::abs(pc.getPosition().second - col) == 1) {
//         attack(pc, level.isAttackSuccess());
//     }

//     // use randomDir in level to move randomly
//     for (int tries = 0; tries < 4; ++tries) {
//         Direction dir = level.randomDir();
//         auto [dr, dc] = dirToDelta(dir);
//         int nr = row + dr, nc = col + dc;
//         if (map.isPassible(nr, nc)) { 
//             map.moveCharacter(row, col, nr, nc);
//             row = nr;
//             col = nc;
//             break;
//         }
//     }
// }

// void Halfling::attack(Player& pc, bool isAttackSuccessful) {
//     if (isAttackSuccessful) {
//         pc.beAttackedBy(this);
//     }
// }

// int Halfling::beAttackedBy(Character* attacker) {
//     int dmg = this->calculateDamage(attacker->getAtk(), this->getDef());
//     this->hp -= dmg;
//     return dmg;
// }

// void Halfling::dropLoot(Level& level, Map& map) const {
//     level.placeGold(2, map.getTile(row, col));
// }
