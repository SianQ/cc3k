#include "Halfling.h"
#include "Gold.h"
#include <cstdlib>
#include "Direction.h"

// enum class Direction {
//     North,    
//     South,    
//     East,     
//     West,     
//     NorthEast,
//     NorthWest,
//     SouthEast,
//     SouthWest 
// };


Halfling::Halfling()
  : Enemy(100,15,20,"L",true,false) {}

void Halfling::act(Map& map, Player& pc, Level& level) {
    // check if the player is adjacent, if so, attack if isAttackSuccess is true (a random chance generated by level)
    for (int i = 0; i < 4; ++i) {
        Direction dir = static_cast<Direction>(i);
        int dr = 0, dc = 0;
        switch (dir) {
            case Direction::North:    dr = -1; dc = 0; break;
            case Direction::South:    dr = 1;  dc = 0; break;
            case Direction::East:     dr = 0;  dc = 1; break;
            case Direction::West:     dr = 0;  dc = -1; break;
        }

    for(int r=-1; r<=1; ++r) {
        for(int c=-1; c<=1; ++c) {
            if(r==0 && c==0) continue;
            int nr=row+r, nc=col+c;
            if(!map.isPassible(nr,nc)) continue;
            auto *ch = map.getTile(nr,nc).getCharacter();
            if(ch && ch->isPlayer()) {
                attack(pc, level.isAttackSuccess());
                return;
            }
        }
    }
    // use randomDir in level to move randomly
    auto [dr, dc] = level.getRandomDir();
    int nr = row + dr, nc = col + dc;
    if (map.isPassible(nr, nc)) {
        map.moveCharacter(row, col, nr, nc);
        row = nr;
        col = nc;
    }
}

void Halfling::attack(Player& pc, bool isAttackSuccessful) {
    if (isAttackSuccessful) {
        pc.beAttackedBy(this);
    }
}

int Halfling::beAttackedBy(Character* attacker) {
    int dmg = this->calculateDamage(attacker->getAtk(), this->getDef());
    this.hp -= dmg;
    return dmg;
}

void Halfling::dropLoot(Level& level, Map& map) const {
    level.placeGold(2, map.getTile(row, col));
}
