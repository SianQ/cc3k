#include "Enemy.h"
#include "Map.h"
#include "Player.h"
#include "Level.h"
#include "Gold.h"
#include "Potion.h"

#include <cstdlib>    
#include <utility>    

Enemy::Enemy(int hp_, int atk_, int def_,             
             const std::string& typeSymbol,
             bool hostile_, bool isDragon_,
             int row, int col)
  : Character(hp_, atk_, def_, row, col), // maxHP is not used in this context
    hostile(hostile_), isDragon(isDragon_), type(typeSymbol) {}

bool Enemy::isHostile() const {
    return hostile;
}

void Enemy::setHostile(bool h) {
    hostile = h;
}

bool Enemy::dragon() const {
    return isDragon;
}

char Enemy::getSymbol() const {
    return type[0];
}
std::string Enemy::getRace() const { return race; }



static inline std::pair<int,int> dirToDelta(Direction d) {
    switch (d) {
        case Direction::North: return {-1, 0};
        case Direction::South: return { 1, 0};
        case Direction::East:  return { 0, 1};
        case Direction::West:  return { 0,-1};
        default:               return { 0, 0}; 
    }
}


void Enemy::act(Map& map, Player& pc, Level& level) {
    if (this->isDead()) return;

    // check if the player is adjacent, if so, attack if isAttackSuccess is true (a random chance generated by level)
    if (std::abs(pc.getPosition().first - row) + std::abs(pc.getPosition().second - col) == 1) {
        attack(pc, level.isAttackSuccess());
    }

    // use randomDir in level to move randomly
    for (int tries = 0; tries < 4; ++tries) {
        Direction dir = level.randomDir();
        auto [dr, dc] = dirToDelta(dir);
        int nr = row + dr, nc = col + dc;
        if (map.isPassible(nr, nc)) { 
            map.moveCharacter(row, col, nr, nc);
            row = nr;
            col = nc;
            break;
        }
    }
}

void Enemy::attack(Player& pc, bool isAttackSuccessful) {
    if (isAttackSuccessful) {
        pc.beAttackedBy(this);
    }
}

int Enemy::beAttackedBy(Character* attacker) {
    int dmg = this->calculateDamage(attacker->getAtk(), this->getDef());
    this->hp -= dmg;
    return dmg;
}

void Enemy::dropLoot(Level& level, Map& map) const {}

