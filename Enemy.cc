module Enemy;
import Map;
import Player;
import Level;
import Gold;
import Potion;
import <cstdlib>;
import <utility>;

Enemy::Enemy(int hp_, int atk_, int def_,             
             const std::string& typeSymbol,
             bool hostile_, bool isDragon_,
             int x, int y)
  : Character(hp_, atk_, def_, x, y, hp_), // Pass hp_ as maxHP
    hostile(hostile_), isDragon(isDragon_), type(typeSymbol) {}

bool Enemy::isHostile() const {
    return hostile;
}

void Enemy::setHostile(bool h) {
    hostile = h;
}

char Enemy::getSymbol() const {
    return type[0];
}
std::string Enemy::getRace() const { return race; }



static inline std::pair<int,int> dirToDelta(Direction d) {
    switch (d) {
        case Direction::North: return {-1, 0};
        case Direction::South: return { 1, 0};
        case Direction::East:  return { 0, 1};
        case Direction::West:  return { 0,-1};
        default:               return { 0, 0}; 
    }
}


void Enemy::act(Map& map, Player& pc, Level& level) {
    // If dead and haven't processed death yet, handle death cleanup
    if (this->isDead() && !deathProcessed) {
        map.clearTile(x, y);
        dropLoot(level, map);
        deathProcessed = true;
        return;
    }
    
    // If dead and already processed, do nothing
    if (this->isDead()) {
        return;
    }

    // check if the player is adjacent, if so, attack if isAttackSuccess is true (a random chance generated by level)
    if (std::abs(pc.getPosition().first - x) + std::abs(pc.getPosition().second - y) == 1) {
        attack(pc, level.isAttackSuccess(), level);
    }

    // use randomDir in level to move randomly
    for (int tries = 0; tries < 4; ++tries) {
        Direction dir = level.randomDir();
        auto [dr, dc] = dirToDelta(dir);
        int nr = x + dr, nc = y + dc;
        if (map.isPassible(nr, nc)) { 
            map.moveCharacter(x, y, nr, nc);
            x = nr;
            y = nc;
            break;
        }
    }
}

void Enemy::attack(Player& pc, bool isAttackSuccessful, Level& level) {
    if (isAttackSuccessful) {
        int damage = pc.beAttackedBy(this);
        if (damage > 0) {
            level.appendMessage(type + " deals " + std::to_string(damage) + " damage to PC.");
        }
    } else {
        level.appendMessage(type + " misses PC.");
    }
}

int Enemy::beAttackedBy(Character* attacker) {
    int dmg = this->calculateDamage(attacker->getAtk(), this->getDef());
    this->hp -= dmg;
    return dmg;
}

void Enemy::dropLoot(Level& level, Map& map) const {}

